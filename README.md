# Terraform-Based AWS User Management System
Web app for Users API with bootstrapping database.

## Health Check API
The health check API allows the user to monitor the health of the application instance and alert the user when something is not working as expected.  
The health check API prevents the user from sending traffic to unhealthy application instances and automatically replace/repair them. It also helps the user improve user experience by not routing their quests to unhealthy instances.

## /healthz endpoint implementation
1. HTTP 200 OK is returned if the connection is successful.
2. HTTP 503 Service Unavailable is returned if the connection is unsuccessful.
3. The API response is not cached. Added cache-control: 'no-cache' header to the response.
4. The API request does not allow for any payload. The response code is 400 Bad Request if the request includes any payload.
5. The API response does not include any payload.
6. Only HTTP GET method is supported for the /healthz endpoint.

## API endpoints 
1. ```/v1/user``` endpoint will enable user to create a new user.
2. Only HTTP POST method is supported for the ```/v1/user``` endpoint.
3. ```/v1/user/self``` endpoint will enable user to update or fetch user details using Basic Authentication.
4. Only HTTP PUT and GET methods are supported for the ```/v1/user/self``` endpoint.
5. ```/v1/user/self/pic``` endpoint will enable users to add images (profile pictures) to their user accounts.
6. Only HTTP POST, GET and DELETE methods are supported for the ```/v1/user/self/pic``` endpoint.
7. The application supports popular image formats, such as png, jpg, and jpeg.
8. Each image is stored in an S3 bucket, and object metadata is stored in the database.
9.  Users can (hard) delete images from the S3 bucket as long as they are the ones who added the image.
10. The user cannot delete an image from a different profile.
11. Updating images is not supported. The user is expected to delete the existing image and attach a new one for the update.

## User API implementation.
1. Your web application must only support Token-Based Basic authentication and not Session Authentication.
2. As a user, I must provide a basic authentication token when making an API call to the authenticated endpoint.
3. Create a new user
    1. As a user, I want to create an account by providing the following information.
        1. Email Address
        2. Password
        3. First Name
        4. Last Name
    2. account_created field for the user should be set to the current time when user creation is successful.
    3. Users should not be able to set values for account_created and account_updated. Any value provided for these fields must be ignored.
    4. Password should never be returned in the response payload.
    5. As a user, I expect to use my email address as my username.
    6. The application must return a 400 Bad Request HTTP response code when a user account with the email address already exists.
    7. As a user, I expect my password to be stored securely using the BCrypt password hashing scheme with salt.
4. Update user information
    1. As a user, I want to update my account information. I should only be allowed to update the following fields.
        1. First Name 
        2. Last Name
        3. Password 
        4. Attempting to update any other field should return a 400 Bad Request HTTP response code.
        5. account_updated field for the user should be updated when the user update is successful.
        6. A user can only update their own account information.
5. Get user information 
    1. As a user, I want to get my account information.
    2. Response payload should return all fields for the user except for the password.

## Application Logs
1. The application generates meaningful log messages and writes them to a file.
2. Logs are available in CloudWatch in near real-time.
3. A new log group & stream is created for the stack.

## Application Metrics
1. Sending requests to APIs will generate custom metrics for API counts and timings.
2. Metrics are available in CloudWatch in near real-time.

## Run this project on an EC2 instance with RDS
1. You will need to have an IaC ready for deployment which will use the custom AMI built by packer.
2. Run the packer build by merging a pull request.
3. Use the AMI generated by the packer build in the Terraform IaC.
4. A VPC with the WebApp EC2 instance will be launched.
5. Test the endpoints using Postman/Bruno/curl or any other application. 

## Run this project on DigitalOcean
1. Create a droplet on DigitalOcean and and SSH with the droplet.
2. Connect to the VM and install Node.js and MySQL. Next, configure MySQL and create a database.
3. Clone the repository and copy the repository to the VM.
4. Navigate to the repository folder in the VM and run ```npm install``` to install all the required dependencies.
5. Copy or create an ```.env``` file and add the required credentials as given - 
```
PORT=8080
DB_HOST=localhost
DB_NAME=<your_database_name>
DB_USER=<your_username>
DB_PASSWORD=<your_password>
```
6. Run the command ```node server.js``` to run the application.
7. Test application health and user APIs using Postman/Bruno/curl or any other application.

## Run this project locally
1. Clone this repository.
2. Navigate to the root of the repository and run ```npm install``` to install all the required dependencies.
3. Create a ```.env``` file and add the required credentials as given - 
```
PORT=8080
DB_HOST=localhost
DB_NAME=<your_database_name>
DB_USER=<your_username>
DB_PASSWORD=<your_password>
```
4. Run the command ```node server.js``` at root directory to run the application.
5. Test the /healthz endpoint using Postman/Bruno/curl or any other application.

## Continuous Integration (CI) with GitHub Actions for Web App
Added a GitHub Actions workflow to run the application tests for each pull request raised. A pull request can only be merged if the workflow executes successfully.
Added Status Checks GitHub branch protection to prevent users from merging a pull request when the GitHub Actions workflow run fails.

## Packer Continuous Integration - GitHub Actions Workflow for Status Check
When a pull request is raised, this GitHub Actions workflow does the following:
1. Runs the packer fmt command. If this command modifies the packer template, the workflow fails and prevent users from merging the pull request.
2. Runs the packer validate command. If this command fails to validate the packer template, the workflow fails, and users should be prevented from merging the pull request.

## Packer Continuous Integration - GitHub Actions Workflow to Build Packer custom image
When a pull request is merged, this GitHub Actions workflow should be triggered to do the following:
1. Build the application artifact (.zip).
2. Build a custom AMI to be used by the VPC created by Terraform.

## Tech stack used
Node.js, Express.js, MySQL, Sequelize, EC2, Packer, Terraform, DigitalOcean.
Test
